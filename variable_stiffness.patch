diff --git a/src/states/SoftFootState.cpp b/src/states/SoftFootState.cpp
index 3745982..cd8eb5c 100644
--- a/src/states/SoftFootState.cpp
+++ b/src/states/SoftFootState.cpp
@@ -10,6 +10,7 @@
 #include <cmath>
 #include <functional>
 #include <numeric>
+#include <thread>
 
 #include <mc_mujoco/devices/RangeSensor.h>
 #include <mc_tasks/CoMTask.h>
@@ -137,12 +138,12 @@ void SoftFootState::start()
   ctl.logger().addLogEntry("nr_footstep", [this]() { return nr_footstep_; });
 
   ctl.gui()->addElement({"SoftFoot"},
-                        mc_rtc::gui::Label("PhalangesStiffness", [this]() { return this->PhalangesStiffness_; }));
-  ctl.logger().addLogEntry("PhalangesStiffness", [this]() { return PhalangesStiffness_; });
+                        mc_rtc::gui::Label("PhalangesStiffness", [this]() { const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_); return this->PhalangesStiffness_; }));
+  ctl.logger().addLogEntry("PhalangesStiffness", [this]() { const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_); return PhalangesStiffness_; });
 
   ctl.gui()->addElement({"SoftFoot"},
-                        mc_rtc::gui::Label("Air_Pressure", [this]() { return this->pressure_; }));
-  ctl.logger().addLogEntry("Air_Pressure", [this]() { return pressure_; });
+                        mc_rtc::gui::Label("Air_Pressure", [this]() { const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_); return this->pressure_; }));
+  ctl.logger().addLogEntry("Air_Pressure", [this]() { const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_); return pressure_; });
 
   ctl.gui()->addElement({"SoftFoot"},
                         mc_rtc::gui::Label("Desired_Pressure", [this]() { return this->D_; }));
@@ -153,8 +154,10 @@ void SoftFootState::start()
   ctl.logger().addLogEntry("WhichFoot", [this]() { return WhichFoot_; });
 
   ctl.gui()->addElement({"SoftFoot"},
-                        mc_rtc::gui::Label("valvesStatus", [this]() { return this->valvesStatus_; }));
-  ctl.logger().addLogEntry("valvesStatus", [this]() { return valvesStatus_; });
+                        mc_rtc::gui::Label("Right valvesStatus", [this]() { return this->foot_data_[Foot::Right].valves_status; }));
+
+  ctl.gui()->addElement({"SoftFoot"},
+                        mc_rtc::gui::Label("Left valvesStatus", [this]() { return this->foot_data_[Foot::Left].valves_status; }));
 
   ctl.gui()->addElement({"SoftFoot"},
                         mc_rtc::gui::Label("Monitor_Left", [this]() { return this->ML_; }));
@@ -317,7 +320,7 @@ void SoftFootState::start()
                              return t += ctl.solver().dt();
                            }),
       mc_rtc::gui::plot::Y(
-          "SoleStiffness", [this]() { return this->PhalangesStiffness_; }, mc_rtc::gui::Color::Blue));
+          "SoleStiffness", [this]() { const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_); return this->PhalangesStiffness_; }, mc_rtc::gui::Color::Blue));
 
 
   ctl.gui()->addPlot(
@@ -329,7 +332,7 @@ void SoftFootState::start()
                              return t += ctl.solver().dt();
                            }),
       mc_rtc::gui::plot::Y(
-          "Pressure", [this]() { return this->pressure_; }, mc_rtc::gui::Color::Blue));
+          "Pressure", [this]() { const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_); return this->pressure_; }, mc_rtc::gui::Color::Blue));
 
   ctl.gui()->addPlot(
       "WhichFoot",
@@ -351,7 +354,9 @@ void SoftFootState::start()
                              return t += ctl.solver().dt();
                            }),
       mc_rtc::gui::plot::Y(
-          "valvesStatus", [this]() { return this->valvesStatus_; }, mc_rtc::gui::Color::Blue));
+          "Left valvesStatus", [this]() { return this->foot_data_[Foot::Left].valves_status; }, mc_rtc::gui::Color::Blue),
+      mc_rtc::gui::plot::Y(
+          "Right valvesStatus", [this]() { return this->foot_data_[Foot::Right].valves_status; }, mc_rtc::gui::Color::Red));
 
   ctl.gui()->addPlot(
       "Monitor_Left",
@@ -534,7 +539,7 @@ void SoftFootState::runState()
                                  [this, foot, range_sensor_name]()
                                  { return range_sensor_data_[foot][range_sensor_name]; });
       }
-      ctl.logger().addLogEntry("MyMeasures_" + name + "_k", [this, foot]() { return foot_data_[foot].k; });
+      ctl.logger().addLogEntry("MyMeasures_" + name + "_k", [this, foot]() { const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_); return foot_data_[foot].k; });
       ctl.logger().addLogEntry("MyMeasures_" + name + "_angle", [this, foot]() { return foot_data_[foot].angle; });
       ctl.logger().addLogEntry("MyMeasures_" + name + "_z_offset",
                                [this, foot]() { return foot_data_[foot].position_offset_z; });
@@ -542,6 +547,8 @@ void SoftFootState::runState()
                                [this, foot]() { return foot_data_[foot].min_max_phalanxes_angle; });
       ctl.logger().addLogEntry("MyMeasures_" + name + "_position_offset",
                                [this, foot]() { return foot_data_[foot].position_offset_x; });
+      ctl.logger().addLogEntry("MyMeasures_" + name + "_valves_status",
+                               [this, foot]() { const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_); return foot_data_[foot].valves_status; });
       ctl.logger().addLogEntry("MyMeasures_" + name + "_phalanxes_x",
                                [this, foot]()
                                {
@@ -589,6 +596,38 @@ void SoftFootState::runState()
     }
   }
 
+  // Returns true if single support has elpased \p ratio of its time
+  auto checkSingleSupportTime = [&](double ratio)
+  {
+    return ctl.swingTraj->t_
+           > ctl.swingTraj->startTime_ + (ctl.swingTraj->endTime_ - ctl.swingTraj->startTime_) * ratio;
+  };
+
+  auto belowSingleSupportTime = [&](double ratio)
+  {
+    return ctl.swingTraj->t_
+           < ctl.swingTraj->startTime_ + (ctl.swingTraj->endTime_ - ctl.swingTraj->startTime_) * ratio;
+  };
+
+  // Open the valves
+  if(foot_data_[current_moving_foot].valves_status == 0 && checkSingleSupportTime(0.05) && belowSingleSupportTime(0.75))
+  {
+    if(with_variable_stiffness_)
+    {
+      updateVariableStiffness(ctl, current_moving_foot, true);
+    }
+  }
+
+  // Close the valves
+  if(foot_data_[current_moving_foot].valves_status == 1 && checkSingleSupportTime(0.8))
+  {
+    // call the server and update the variable stiffness
+    if(with_variable_stiffness_)
+    {
+      updateVariableStiffness(ctl, current_moving_foot, false);
+    }
+  }
+
   // Check foot position with respect to desired landing pose
   const auto & ground = foot_data_[current_moving_foot].ground;
   if(ground.empty())
@@ -605,13 +644,6 @@ void SoftFootState::runState()
                                                                + landing_to_foot_middle_offset_ - foot_length_ * 0.55
                                                                - extra_to_compute_best_position_;
 
-  // Returns true if single support has elpased \p ratio of its time
-  auto checkSingleSupportTime = [&](double ratio)
-  {
-    return ctl.swingTraj->t_
-           > ctl.swingTraj->startTime_ + (ctl.swingTraj->endTime_ - ctl.swingTraj->startTime_) * ratio;
-  };
-
   if(!foot_data_[current_moving_foot].computation_done && enough_ground_in_front && enough_ground_in_back
      && checkSingleSupportTime(0.5))
   {
@@ -646,11 +678,7 @@ void SoftFootState::runState()
               "[SoftFootState] extractAltitudeProfileFromGroundSegment(current_moving_foot) took {:.4f}ms",
               duration.count());
         }
-        // call the server and update the variable stiffness
-        if(with_variable_stiffness_)
-        {
-          updateVariableStiffness(ctl, current_moving_foot);
-        }
+
         // Compute convex hull of the segment -> right now it does not work
         {
           auto start = std::chrono::high_resolution_clock::now();
@@ -716,18 +744,6 @@ void SoftFootState::runState()
     // mc_rtc::log::warning("[SoftFootState] Accumulating data -> ground.back().x() {} {}", ground.back().x(),
     // X_0_landing.translation().x() + foot_length_ * 0.5 + extra_to_compute_best_position_);
   }
-
-  if(checkSingleSupportTime(0.9))
-  {
-    srv.request.valvesStatus = 0; // Close the solenoid
-    valvesStatus_ = 0;
-  }
-  if(checkSingleSupportTime(0.05))
-  {
-    srv.request.valvesStatus = 1; // Open the solenoid
-    valvesStatus_ = 1;
-  }
-
 }
 
 bool SoftFootState::checkTransitions()
@@ -747,7 +763,6 @@ void SoftFootState::teardown()
   ctl.logger().removeLogEntry("PhalangesStiffness");
   ctl.logger().removeLogEntry("Air_Pressure");
   ctl.logger().removeLogEntry("WhichFoot");
-  ctl.logger().removeLogEntry("valvesStatus");
 }
 
 void SoftFootState::calculateCost(mc_control::fsm::Controller & ctl)
@@ -1097,55 +1112,90 @@ void SoftFootState::extractAltitudeProfileFromGroundSegment(const Foot & current
   // Get the segment
   const auto & raw_segment = ground_segment_[current_moving_foot].raw;
   // Save the selected segment in raw data of ground segment structure
-  std::transform(raw_segment.begin(), raw_segment.end(), std::back_inserter(foot_data_[current_moving_foot].altitude),
-                 [](const Eigen::Vector3d & v) { return v.z(); });
+  {
+    const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_);
+    std::transform(raw_segment.begin(), raw_segment.end(), std::back_inserter(foot_data_[current_moving_foot].altitude),
+                  [](const Eigen::Vector3d & v) { return v.z(); });
+  }
 }
 
 void SoftFootState::updateVariableStiffness(mc_control::fsm::Controller & ctl,
-                                        const Foot & current_moving_foot)
+                                        const Foot & current_moving_foot, bool open_valve)
 {
-  variable_stiffness::connectionFile srv;
-  srv.request.profile = foot_data_[current_moving_foot].altitude;
-
-  if(current_moving_foot == Foot::Left)
-  {
-    srv.request.WhichFoot = 0;
-    WhichFoot_ = 0;
-  }
-  else
   {
-    srv.request.WhichFoot = 1;
-    WhichFoot_ = 1;
-  }
-  
-  if(client_.call(srv))
-  {
-    mc_rtc::log::success("[SoftFootState] We udpate the sole stiffness with {}", srv.response.stiffness, srv.response.pressure);
-    foot_data_[current_moving_foot].k = srv.response.stiffness;
- 
-    // Solution to modify the variable stiffness
-    auto stiffnessToAngle = [this](double VarStiff)
+    const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_);
+    if(foot_data_[current_moving_foot].altitude.empty())
     {
-      double angle_low = 0;
-      double angle_high = 1;
-      double stiffness_low = 0;
-      double stiffness_high = 100;
-      return angle_low + (VarStiff - stiffness_low) * (angle_high - angle_low) / (stiffness_high - stiffness_low);
-    };
-    auto postureTask = ctl.getPostureTask(ctl.robot().name());
-    // Reset stifness for both feet gains
-    postureTask->jointGains(ctl.solver(),
-                            {tasks::qp::JointGains("R_VARSTIFF", 350), tasks::qp::JointGains("L_VARSTIFF", 350)});
-    // Set computed stiffness for current moving foot
-    PhalangesStiffness_ = foot_data_[current_moving_foot].k;
-    pressure_ = srv.response.pressure;
-    postureTask->target({{variable_stiffness_jointname_[current_moving_foot],
-                          std::vector<double>{stiffnessToAngle(foot_data_[current_moving_foot].k)}}});
-  }
-  else
-  {
-    mc_rtc::log::error("[SoftFootState] Failed to call service connectionFile to compute the variable stiffness");
+      // mc_log::error:("[SoftFootState::updateVariableStiffness] The ground is not estimated");
+      return;
+    }
   }
+
+  // Here we detach a thread to use the service so it is not to slow
+  std::thread([this, &ctl, current_moving_foot, open_valve]()
+    {
+      variable_stiffness::connectionFile srv;
+      srv.request.profile = foot_data_[current_moving_foot].altitude;
+
+      if(open_valve)
+      {
+        const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_);
+        srv.request.valvesStatus = 1; // Open the solenoid
+        foot_data_[current_moving_foot].valves_status = 1;
+        mc_rtc::log::error("Open for {}", current_moving_foot == Foot::Right ? "Right" : "Left");
+      }
+      else
+      {
+        const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_);
+        srv.request.valvesStatus = 0; // Close the solenoid
+        foot_data_[current_moving_foot].valves_status = 0;
+        foot_data_[current_moving_foot].altitude.clear();
+        mc_rtc::log::error("Close for {}", current_moving_foot == Foot::Right ? "Right" : "Left");
+      }
+
+      if(current_moving_foot == Foot::Left)
+      {
+        srv.request.WhichFoot = 0;
+        WhichFoot_ = 0;
+      }
+      else
+      {
+        srv.request.WhichFoot = 1;
+        WhichFoot_ = 1;
+      }
+
+      if(client_.call(srv) && foot_data_[current_moving_foot].valves_status == 1)
+      {
+        const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_);
+        mc_rtc::log::success("[SoftFootState] We udpate the sole stiffness with {}", srv.response.stiffness, srv.response.pressure);
+        foot_data_[current_moving_foot].k = srv.response.stiffness;
+
+        // Solution to modify the variable stiffness
+        auto stiffnessToAngle = [this](double VarStiff)
+        {
+          double angle_low = 0;
+          double angle_high = 1;
+          double stiffness_low = 0;
+          double stiffness_high = 100;
+          return angle_low + (VarStiff - stiffness_low) * (angle_high - angle_low) / (stiffness_high - stiffness_low);
+        };
+        auto postureTask = ctl.getPostureTask(ctl.robot().name());
+        // Reset stifness for both feet gains
+        postureTask->jointGains(ctl.solver(),
+                                {tasks::qp::JointGains("R_VARSTIFF", 350), tasks::qp::JointGains("L_VARSTIFF", 350)});
+        // Set computed stiffness for current moving foot
+        PhalangesStiffness_ = foot_data_[current_moving_foot].k;
+        pressure_ = srv.response.pressure;
+        postureTask->target({{variable_stiffness_jointname_[current_moving_foot],
+                              std::vector<double>{stiffnessToAngle(foot_data_[current_moving_foot].k)}}});
+      }
+      else
+      {
+        mc_rtc::log::error("[SoftFootState] Failed to call service connectionFile to compute the variable stiffness");
+      }
+
+      mc_rtc::log::info("Finish to handled stiffness changes");
+    }).detach();
 }
 
 void SoftFootState::computeSegmentConvexHull(mc_control::fsm::Controller & ctl, const Foot & current_moving_foot)
@@ -1305,7 +1355,11 @@ void SoftFootState::computeMinMaxAngle(const Foot & current_moving_foot)
     const double MASS_PHALANX = 0.2;
     const double MASS_ROBOT = 43.;
     const double nr_phalanxes = static_cast<double>(nr_phalanxes_);
-    const double k = foot_data_[current_moving_foot].k;
+    double k = 0.;
+    {
+      const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_);
+      k = foot_data_[current_moving_foot].k;
+    }
     const double d = 2.;
     const double f0 = MASS_ROBOT * 9.81 * (foot_length_ / 2.);
     const double I = (10. * MASS_PHALANX * phalanx_length_ * phalanx_length_) / 3.;
@@ -1943,22 +1997,25 @@ void SoftFootState::reset(mc_control::fsm::Controller & ctl, const Foot & foot)
   foot_data_[foot].position_offset_x = 0.;
   foot_data_[foot].position_offset_z = 0.;
 
-  if(ctl.robot().hasJoint("L_VARSTIFF"))
   {
-    auto angleToStiffness = [this](double angle)
+    const std::lock_guard<std::mutex> lock(variable_stiffness_mutex_);
+    if(ctl.robot().hasJoint("L_VARSTIFF"))
     {
-      double angle_low = 0;
-      double angle_high = 1;
-      double stiffness_low = 0;
-      double stiffness_high = 100;
-      return stiffness_low + (angle - angle_low) * (stiffness_high - stiffness_low) / (angle_high - angle_low);
-    };
-    foot_data_[foot].k = angleToStiffness(
-        ctl.robot().q()[ctl.robot().jointIndexByName(foot == Foot::Left ? "L_VARSTIFF" : "R_VARSTIFF")][0]);
-  }
-  else
-  {
-    foot_data_[foot].k = 0.;
+      auto angleToStiffness = [this](double angle)
+      {
+        double angle_low = 0;
+        double angle_high = 1;
+        double stiffness_low = 0;
+        double stiffness_high = 100;
+        return stiffness_low + (angle - angle_low) * (stiffness_high - stiffness_low) / (angle_high - angle_low);
+      };
+      foot_data_[foot].k = angleToStiffness(
+          ctl.robot().q()[ctl.robot().jointIndexByName(foot == Foot::Left ? "L_VARSTIFF" : "R_VARSTIFF")][0]);
+    }
+    else
+    {
+      foot_data_[foot].k = 0.;
+    }
   }
 
   // Delete all the data that are behind the foot
@@ -1988,10 +2045,23 @@ void SoftFootState::reset(mc_control::fsm::Controller & ctl, const Foot & foot)
   ground_segment_[foot].filtered.clear();
   ground_segment_[foot].convex.clear();
 
+
   // Get name for the feet
   const Foot other_foot = foot == Foot::Left ? Foot::Right : Foot::Left;
   const std::string other_name = other_foot == Foot::Left ? "left" : "right";
   const std::string name = foot == Foot::Left ? "left" : "right";
+
+  // Make sure to close the valve
+  if(foot_data_[other_foot].valves_status == 1)
+  {
+    // call the server and update the variable stiffness
+    if(with_variable_stiffness_)
+    {
+      mc_rtc::log::error("Close for {}", other_foot == Foot::Right ? "Right" : "Left");
+      updateVariableStiffness(ctl, other_foot, false);
+    }
+  }
+
   // Reset logger
   ctl.logger().removeLogEntry("MyMeasures_" + other_name + "_range");
   for(const auto & range_sensor_name : range_sensor_names_[foot])
@@ -2014,6 +2084,7 @@ void SoftFootState::reset(mc_control::fsm::Controller & ctl, const Foot & foot)
   ctl.logger().removeLogEntry("MyMeasures_" + other_name + "_z_offset");
   ctl.logger().removeLogEntry("MyMeasures_" + other_name + "_min_max_phalanxes_angle");
   ctl.logger().removeLogEntry("MyMeasures_" + other_name + "_position_offset");
+  ctl.logger().removeLogEntry("MyMeasures_" + other_name + "_valves_status");
   ctl.logger().removeLogEntry("MyMeasures_" + other_name + "_phalanxes_x");
   ctl.logger().removeLogEntry("MyMeasures_" + other_name + "_phalanxes_y");
 
diff --git a/src/states/SoftFootState.h b/src/states/SoftFootState.h
index 665ab35..eb4ee61 100644
--- a/src/states/SoftFootState.h
+++ b/src/states/SoftFootState.h
@@ -155,7 +155,7 @@ protected:
 
   void extractAltitudeProfileFromGroundSegment(const Foot & current_moving_foot);
 
-  void updateVariableStiffness(mc_control::fsm::Controller & ctl, const Foot & current_moving_foot);
+  void updateVariableStiffness(mc_control::fsm::Controller & ctl, const Foot & current_moving_foot, bool open_valve);
 
   void computeSegmentConvexHull(mc_control::fsm::Controller & ctl, const Foot & current_moving_foot);
 
@@ -202,9 +202,9 @@ protected:
   double pressure_ = 0.0;
   double ML_ = 0.0;
   double MR_ = 0.0;
-  double D_ = 0.0;
-  int WhichFoot_ = 0.0;
-  int valvesStatus_ = 0.0;
+  int WhichFoot_;
+  double D_;
+
   double extra_to_compute_best_position_ = 0.01;
 
   // FootData contains data used to estimate the ground profile
@@ -223,6 +223,7 @@ protected:
     double position_offset_z;
     bool need_reset;
     bool computation_done;
+    int valves_status = 0;
   };
   std::unordered_map<Foot, FootData> foot_data_;
 
@@ -288,6 +289,7 @@ protected:
   void airPressureCallback(const std_msgs::Float64MultiArray::ConstPtr& data);
 
   std::mutex range_sensor_mutex_;
+  std::mutex variable_stiffness_mutex_;
 
   bool debug_output_ = false;
 
